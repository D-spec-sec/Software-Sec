### Fuzzing 
Fuzz testing, also known as fuzzing, involves providing the software with a large amount of random or unexpected inputs to discover vulnerabilities. It helps identify how the software handles unexpected data and can reveal security weaknesses, such as buffer overflows or input validation issues.

### SAST
Analyzing code without execution (SAST): Static Application Security Testing (SAST) involves analyzing the source code, bytecode, or binary code of an application without executing it. SAST is useful for finding vulnerabilities in the code itself but does not involve running the software with random inputs.

### Synthetic transactions
Synthetic transactions typically refer to simulated interactions with a system to monitor its performance, rather than specifically testing for vulnerabilities. It is not a technique focused on exposing software to extensive random inputs for security testing.
Synthetic transactions involve simulating user interactions with the web application to monitor its performance and functionality. By creating automated scripts that mimic real user behavior, John can evaluate the application's response time, availability, and functionality of new features that are infrequently used. This technique allows John to proactively identify performance issues and ensure a positive user experience without relying solely on user-reported issues.

### Unit testing
Unit testing focuses on verifying the correctness of individual units or components of code. While important in the development process, unit testing may not be sufficient for evaluating the overall performance and user experience of a web application, especially after an upgrade.
Unit testing is a software testing technique that focuses on testing individual components or units of code to ensure they function correctly. While unit testing is essential for verifying the functionality of specific code modules, it may not be suitable for evaluating the overall performance of a web application, especially in terms of profitability of new features. Unit testing primarily focuses on code quality and functionality rather than user experience and performance.

### Misuse Case Testing 
focuses on identifying how a malicious entity, such as a hacker, might exploit vulnerabilities in a software application or system. It involves creating scenarios where the system is intentionally misused to uncover potential security weaknesses and vulnerabilities.

### Test Coverage Analysis
involves assessing the extent to which the software has been tested and identifying any gaps in the testing process. By conducting a thorough test coverage analysis, you can prioritize testing efforts on critical areas of the software, ensuring that essential functionalities are thoroughly tested while potentially reducing the overall testing scope to align with the revised budget and schedule.

### Evaluating Integration Test 
focuses on a specific type of testing within the software development process and may not directly address the need to reevaluate the testing approach in line with the revised budget and schedule. While integration testing is crucial, it is just one aspect of the overall testing strategy and may not be the most relevant choice in this scenario.


### SAMM 
(Software Assurance Maturity Model) is specifically designed to assess and improve security practices within software development processes. It focuses on integrating security practices into various business functions to enhance the overall security posture of an organization. SAMM provides a structured approach to advancing security maturity by addressing security practices at each level of business function maturity.


### Confinement
The term "confinement" in the context of software development refers to the practice of restricting the execution of code to a confined environment, often referred to as a sandbox. This approach is employed for security reasons to limit the impact of potential security vulnerabilities in the code.

### Regression
Regression testing is the type of testing specifically designed to verify that recent changes or updates to a software application have not caused any unintended side effects or regressions in existing functionality. It ensures that previously developed and tested features still work as expected after modifications or enhancements have been made to the software.
